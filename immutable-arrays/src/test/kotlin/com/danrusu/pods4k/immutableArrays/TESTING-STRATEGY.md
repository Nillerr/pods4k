## Testing Strategy

Unlike the generic **ImmutableArray** class, all the primitive variants like **ImmutableIntArray**,
**ImmutableBooleanArray**, etc. are generated by the same code and follow the exact same code path. Validating the
behavior of a single primitive variant ensures that all the other primitives variants have the same behavior aside
from operating on different primitive types.

In order to avoid redundant tests which reduce maintainability, only **ImmutableArray** and **ImmutableIntArray**
should be tested for correct behavior. The others should only be tested that they operate and produce the correct types
without validating their behavior since that's inferred from validating the behavior of **ImmutableIntArray**.

### Testing primitive types:

When checking the return type, such as whether a number is a primitive **int**, we can't check whether the class is an
**Int** since a value that is auto-boxed into a **java.lang.Integer** wrapper will also pass that test. We also can't
create a utility function for this check because if that function accepts a generic type then the value will be
auto-boxed even if the function is inline with a reified generic type. Similarly, if a utility method accepts a
primitive type then the value will be automatically unboxed so we won't know the type of the initial value.

#### Differentiating primitives versus wrapper classes:

```kotlin
println(3::class.java) // int

var number: Int? = 3
println(number!!::class.java) // java.lang.Integer
```

#### How to validate primitive types:

Unlike the Java wrapper classes, the primitive classes are not exposed so we can't reference them directly. To
reference these private classes, we need to get the class of a value that is known to be primitive and check against
that instead:

```kotlin
val primitiveIntClass = 3::class.java // int (not java.lang.Integer)

// check if getValue() returns a primitive int
expectThat(getValue()::class.java).isEqualTo(primitiveIntClass)
```
