# Immutable Arrays

A safer and more efficient alternative to read-only lists providing the same type of capabilities and similar-looking
code (see [Benefits over read-only lists](#benefits-over-read-only-lists)).

Immutable arrays are also a safer and cleaner alternative to regular arrays that aren't intended to be mutated
providing significant efficiency improvements over regular arrays for dozens of common operations
(see [Benefits over regular arrays](#benefits-over-regular-arrays)).

Immutable arrays wrap regular arrays with zero-cost abstractions that get eliminated at compile-time. This results in
regular arrays in the generated bytecode along with the optimizations of this library. Unlike regular arrays, the
immutable-array elements cannot be re-assigned, so immutable arrays can be safely shared without needing to be wrapped
in immutable collections:

```kotlin
val names = immutableArrayOf("Dan", "Bob")
println(names[0]) // Dan

names[1] = "Jane" // Compile error: No set method providing array access
```

## Memory Layout

Performing some operation that results in an `ImmutableIntArray` ends up with the following memory layout:

![Memory Layout of immutable arrays](src/main/resources/immutable-array-memory-layout.drawio.png)

Note that the `values` variable of type `ImmutableIntArray` actually references a regular primitive int array.

Here is the same example but operating on a regular primitive array and ending up with a read-only list:

![Memory Layout of Read-only Lists](src/main/resources/list-memory-layout.drawio.png)

Classes that operate on generics, such as lists, can't store primitive types directly. Each 32-bit integer gets
auto-boxed into an `Integer` wrapper object and a pointer to that wrapper is passed to the resulting list. The garbage
collector periodically moves surviving objects around, so we can end up with the objects scattered throughout the heap.

<details>
<summary>Memory Impacts</summary>

Notice that the list contains 7 values but the backing array has a size of 10 with 3 null elements.  `ArrayList` starts
with a default capacity of 10. As elements pass the filter criteria and get added to the array, if the backing array
becomes full, a new array that's 1.5 times larger is created and the elements are copied over. On average, array lists
end up with about 17% of unused capacity when the exact resulting size isn't known ahead of time.

Although a 32-bit integer needs just 4 bytes to represent the value, in a typical 64-bit JVM environment, an `Integer`
wrapper object requires 16 bytes for the object header, 4 bytes for the actual integer value, plus another 4 bytes of
padding totalling 24 bytes. If we enable pointer compression, we can reduce this down to 16 bytes per wrapper.

In addition to the size of the `Integer` wrapper objects, the backing array stores pointers to the memory address of
each of these wrappers. So ignoring the memory overhead of the list object and ignoring the unused over-provisioned
spots, we need 32 bytes to store each 4-byte integer value!  With pointer compression, we can reduce this down to 20
bytes for each 4-byte integer but that's still a 5X increase in memory!

</details>

<details>
<summary>Performance Impacts</summary>

When performing a trivial operation like `readOnlyList.get(index) + 1`, the following steps are performed behind the
scenes (note that this is a simplified explanation of the main steps):

1. Fetch the memory at the address specified by the `readOnlyList` variable to load the ArrayList object.
2. Ensure that `index` is smaller than the list size (enforced by the ArrayList class).
3. Fetch the memory at the address specified by the `elementData` variable from the `ArrayList` class to load the
   backing array object.
4. Ensure that `index` is smaller than the array size. This second check is enforced by the JVM for array accesses.
5. Compute the address of the address for that element into the array (ie. `offset + elementSize * index`)
6. Fetch the memory at that computed location into the array, interpreting it as a pointer, and return that pointer
   back up the chain to the caller of `readOnlyList.get(index)`.
7. Fetch the memory specified by that pointer to get the `Integer` wrapper object.
8. Cast the object to an `Integer` by validating the object header (since generics are erased at compile time).
9. Unbox the `Integer` object into a primitive `int` and finally add 1.

Notice how many steps and memory hops are performed to fetch a single value! Iterating through read-only lists in tight
loops and performing operations on primitive values performs very poorly on modern CPU architectures. That's because
these values are scattered throughout memory resulting in very poor cache locality.

Fetching data from main memory can take several hundred cycles on modern CPU architectures. The CPU tries to minimize
this latency by predicting addresses that will be fetched and pre-fetches data from those locations before they're
actually requested. When these guesses are incorrect, that pre-fetched data is ignored and the values need to be loaded
from the correct address in main memory. Iterating through a primitive array is a best-case scenario as the CPU will
fetch the initial element along with neighboring elements so that subsequent elements are already loaded by the time we
request them. However, the CPU pre-fetcher has a tough time predicting the address of scattered data so this can have a
large impact on performance.

To get an idea of the potential performance impact of wrapper objects, Java Language Architect, Brian Goetz, ran some
benchmarks replacing reference carriers with values as part of project Valhalla exploration. Brian found performance
improvements ranging from 3.5x to 12x faster: [YouTube presentation](https://youtu.be/1H4vmT-Va4o?t=899)

</details>

## Benefits over regular arrays

<details>
<summary>Meaningful toString()</summary>

Unlike regular arrays, calling toString() on immutable arrays produces a pretty representation of the data:

```kotlin
println(immutableArrayOf("Dan", "Bob")) // [Dan, Bob]  Nice!
println(arrayOf("Dan", "Bob")) // [Ljava.lang.String;@7d4991ad  Yuck!
```

</details>

<details>
<summary>Efficient sharing of encapsulated data</summary>

Regular arrays can have their elements reassigned making them a poor choice for encapsulated data that's occasionally
shared. Using an array forces us to duplicate the contents into a collection before sharing so that callers can't
mutate the encapsulated array. This negatively affects performance and adds extra pressure on the garbage collector.
Immutable arrays can be safely shared resulting in cleaner and more efficient code.
</details>

<details>
<summary>Efficient transformations</summary>

Regular arrays are usually chosen for memory or performance reasons, however these benefits are negated when performing
dozens of typical transformations:

```kotlin
val weights = doubleArrayOf(1.5, 3.0, 10.2, 15.7, 2.0)
val interestingWeights = weights.filter { it > 10.0 }
// Oops, all our effort is in vain as this results in a 
// List<Double> auto-boxing each resulting value!
```

Unlike regular arrays, all operations on immutable arrays produce the most efficient type so that clean code is
efficient by default:

```kotlin
val people = immutableArrayOf(
    Person(name = "Dan", age = 3),
    Person(name = "Bob", age = 4),
) // ImmutableArray<Person>

// Mapping the ages automatically uses an efficient ImmutableIntArray[3, 4] storing primitive int values
val ages = people.map { it.age }
performStatisticalAnalysis(ages)
```

Here's a non-exhaustive list of operations that benefit from this significant efficiency improvement (some of these will
be added in future releases):

* map
* mapNotNull
* mapIndexed
* flatMap
* flatMapIndexed
* groupBy
* filter
* filterIndexed
* filterNot
* filterNotNull
* take
* takeWhile
* takeLast
* takeLastWhile
* drop
* dropWhile
* dropLast
* dropLastWhile
* reversed
* sorted
* sortedWith
* sortedBy
* sortedDescending
* sortedByDescending
* partition
* slice
* distinct
* distinctBy
* etc.

</details>

<details>
<summary>Avoids equality & hashCode defects</summary>

Unlike regular arrays, Immutable arrays have a proper equals & hashCode implementation allowing us to compare them in
the same way that we compare lists:

```kotlin
// Yes, this condition will be true when the immutable arrays have identical contents
if (immutableArrayOf(1, 2) == immutableArrayOf(1, 2)) return
```

Since we can compare 2 lists directly, developers occasionally attempt to do the same with regular arrays. Even worse,
defects can sneak in without obvious usages of these broken behaviors:

```kotlin
data class Order(val id: Long, private val products: Array<Product>)

val rejectedOrders = mutableSetOf<Order>()
// Oops, attempting to add Orders to a hashSet will make use of the auto-generated 
// equals & hashCode methods from the Order data class which will in turn rely on 
// the defective equals & hashCode implementation of regular arrays
```

</details>

## Benefits over read-only lists

<details>
<summary>Safer</summary>

Read-only lists appear to be immutable at first as they don't expose any mutating methods. However, they can be cast
into a `MutableList` and modified:

```kotlin
val values = listOf(1, 2, 3)
values[0] = 2 // Compiler error: No set method providing array access

(values as MutableList)[0] = 100
println(values) // [100, 2, 3]
```

Immutable arrays don't have this backdoor:

```kotlin
val values = immutableArrayOf(1, 2, 3)
values[0] = 2 // Compiler error: No set method providing array access

@Suppress("CAST_NEVER_SUCCEEDS")
(values as IntArray)[1] = "Jane"
// ClassCastException: ImmutableIntArray cannot be cast to [I
```

</details>

<details>
<summary>More memory efficient</summary>

Read-only lists containing one of the eight base types, like `List<Int>`, use between 5 to 8 times more memory than
immutable arrays! See the **Memory Impacts** section in [Memory Layout](#memory-layout) for details.

Even when storing generic types, read-only lists still use more memory as their backing array usually has about 17% of
unused capacity. There's also the small memory overhead of the `ArrayList` object whereas variables of immutable array
types point directly at the backing array.

</details>

<details>
<summary>Higher performance</summary>

Executing tight loops on read-only lists containing one of the eight base types, like `List<Int>`, can be over 10 times
slower than immutable arrays. See the **Performance Impacts** section in [Memory Layout](#memory-layout) for details.

Even when operating on generic types, read-only lists have an extra layer of indirection since method calls such as
getting an element, are routed through the `ArrayList` class whereas getting an element from an immutable arrays
accesses the array elements directly.

</details>

## Benefits over immutable lists

## Caveats
